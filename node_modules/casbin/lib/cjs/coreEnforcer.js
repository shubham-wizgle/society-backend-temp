"use strict";
// Copyright 2018 The Casbin Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoreEnforcer = void 0;
const expression_eval_1 = require("expression-eval");
const effect_1 = require("./effect");
const model_1 = require("./model");
const rbac_1 = require("./rbac");
const util_1 = require("./util");
const log_1 = require("./log");
/**
 * CoreEnforcer defines the core functionality of an enforcer.
 */
class CoreEnforcer {
    constructor() {
        this.fm = model_1.FunctionMap.loadFunctionMap();
        this.eft = new effect_1.DefaultEffector();
        this.matcherMap = new Map();
        this.watcher = null;
        this.rm = new rbac_1.DefaultRoleManager(10);
        this.enabled = true;
        this.autoSave = true;
        this.autoBuildRoleLinks = true;
        this.autoNotifyWatcher = true;
    }
    getExpression(asyncCompile, exp) {
        const matcherKey = `${asyncCompile ? 'ASYNC[' : 'SYNC['}${exp}]`;
        let expression = this.matcherMap.get(matcherKey);
        if (!expression) {
            expression = asyncCompile ? expression_eval_1.compileAsync(exp) : expression_eval_1.compile(exp);
            this.matcherMap.set(matcherKey, expression);
        }
        return expression;
    }
    /**
     * loadModel reloads the model from the model CONF file.
     * Because the policy is attached to a model,
     * so the policy is invalidated and needs to be reloaded by calling LoadPolicy().
     */
    loadModel() {
        this.model = model_1.newModel();
        this.model.loadModel(this.modelPath);
        this.model.printModel();
    }
    /**
     * getModel gets the current model.
     *
     * @return the model of the enforcer.
     */
    getModel() {
        return this.model;
    }
    /**
     * setModel sets the current model.
     *
     * @param m the model.
     */
    setModel(m) {
        this.model = m;
    }
    /**
     * getAdapter gets the current adapter.
     *
     * @return the adapter of the enforcer.
     */
    getAdapter() {
        return this.adapter;
    }
    /**
     * setAdapter sets the current adapter.
     *
     * @param adapter the adapter.
     */
    setAdapter(adapter) {
        this.adapter = adapter;
    }
    /**
     * setWatcher sets the current watcher.
     *
     * @param watcher the watcher.
     */
    setWatcher(watcher) {
        this.watcher = watcher;
        watcher.setUpdateCallback(() => __awaiter(this, void 0, void 0, function* () { return yield this.loadPolicy(); }));
    }
    /**
     * setRoleManager sets the current role manager.
     *
     * @param rm the role manager.
     */
    setRoleManager(rm) {
        this.rm = rm;
    }
    /**
     * getRoleManager gets the current role manager.
     */
    getRoleManager() {
        return this.rm;
    }
    /**
     * setEffector sets the current effector.
     *
     * @param eft the effector.
     */
    setEffector(eft) {
        this.eft = eft;
    }
    /**
     * clearPolicy clears all policy.
     */
    clearPolicy() {
        this.model.clearPolicy();
    }
    /**
     * loadPolicy reloads the policy from file/database.
     */
    loadPolicy() {
        return __awaiter(this, void 0, void 0, function* () {
            this.model.clearPolicy();
            yield this.adapter.loadPolicy(this.model);
            this.model.printPolicy();
            if (this.autoBuildRoleLinks) {
                yield this.buildRoleLinksInternal();
            }
        });
    }
    /**
     * loadFilteredPolicy reloads a filtered policy from file/database.
     *
     * @param filter the filter used to specify which type of policy should be loaded.
     */
    loadFilteredPolicy(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            this.model.clearPolicy();
            if ('isFiltered' in this.adapter) {
                yield this.adapter.loadFilteredPolicy(this.model, filter);
            }
            else {
                throw new Error('filtered policies are not supported by this adapter');
            }
            this.model.printPolicy();
            if (this.autoBuildRoleLinks) {
                yield this.buildRoleLinksInternal();
            }
            return true;
        });
    }
    /**
     * isFiltered returns true if the loaded policy has been filtered.
     *
     * @return if the loaded policy has been filtered.
     */
    isFiltered() {
        if ('isFiltered' in this.adapter) {
            return this.adapter.isFiltered();
        }
        return false;
    }
    /**
     * savePolicy saves the current policy (usually after changed with
     * Casbin API) back to file/database.
     */
    savePolicy() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isFiltered()) {
                throw new Error('Cannot save a filtered policy');
            }
            const flag = yield this.adapter.savePolicy(this.model);
            if (!flag) {
                return false;
            }
            if (this.watcher) {
                return yield this.watcher.update();
            }
            return true;
        });
    }
    /**
     * enableEnforce changes the enforcing state of Casbin, when Casbin is
     * disabled, all access will be allowed by the enforce() function.
     *
     * @param enable whether to enable the enforcer.
     */
    enableEnforce(enable) {
        this.enabled = enable;
    }
    /**
     * enableLog changes whether to print Casbin log to the standard output.
     *
     * @param enable whether to enable Casbin's log.
     */
    enableLog(enable) {
        log_1.getLogger().enableLog(enable);
    }
    /**
     * enableAutoSave controls whether to save a policy rule automatically to
     * the adapter when it is added or removed.
     *
     * @param autoSave whether to enable the AutoSave feature.
     */
    enableAutoSave(autoSave) {
        this.autoSave = autoSave;
    }
    /**
     * enableAutoNotifyWatcher controls whether to save a policy rule automatically notify the Watcher when it is added or removed.
     * @param enable whether to enable the AutoNotifyWatcher feature.
     */
    enableAutoNotifyWatcher(enable) {
        this.autoNotifyWatcher = enable;
    }
    /**
     * enableAutoBuildRoleLinks controls whether to save a policy rule
     * automatically to the adapter when it is added or removed.
     *
     * @param autoBuildRoleLinks whether to automatically build the role links.
     */
    enableAutoBuildRoleLinks(autoBuildRoleLinks) {
        this.autoBuildRoleLinks = autoBuildRoleLinks;
    }
    /**
     * buildRoleLinks manually rebuild the role inheritance relations.
     */
    buildRoleLinks() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.buildRoleLinksInternal();
        });
    }
    /**
     * buildIncrementalRoleLinks provides incremental build the role inheritance relations.
     * @param op policy operation
     * @param ptype g
     * @param rules policies
     */
    buildIncrementalRoleLinks(op, ptype, rules) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.model.buildIncrementalRoleLinks(this.rm, op, 'g', ptype, rules);
        });
    }
    buildRoleLinksInternal() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.rm.clear();
            yield this.model.buildRoleLinks(this.rm);
        });
    }
    privateEnforce(asyncCompile = true, ...rvals) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.enabled) {
                return true;
            }
            const functions = {};
            this.fm.getFunctions().forEach((value, key) => {
                functions[key] = value;
            });
            const astMap = this.model.model.get('g');
            astMap === null || astMap === void 0 ? void 0 : astMap.forEach((value, key) => {
                const rm = value.rm;
                functions[key] = util_1.generateGFunction(rm);
            });
            const expString = (_b = (_a = this.model.model.get('m')) === null || _a === void 0 ? void 0 : _a.get('m')) === null || _b === void 0 ? void 0 : _b.value;
            if (!expString) {
                throw new Error('Unable to find matchers in model');
            }
            const effectExpr = (_d = (_c = this.model.model.get('e')) === null || _c === void 0 ? void 0 : _c.get('e')) === null || _d === void 0 ? void 0 : _d.value;
            if (!effectExpr) {
                throw new Error('Unable to find policy_effect in model');
            }
            const HasEval = util_1.hasEval(expString);
            let expression;
            if (!HasEval) {
                expression = this.getExpression(asyncCompile, expString);
            }
            const p = (_e = this.model.model.get('p')) === null || _e === void 0 ? void 0 : _e.get('p');
            const policyLen = (_f = p === null || p === void 0 ? void 0 : p.policy) === null || _f === void 0 ? void 0 : _f.length;
            const rTokens = (_h = (_g = this.model.model.get('r')) === null || _g === void 0 ? void 0 : _g.get('r')) === null || _h === void 0 ? void 0 : _h.tokens;
            const rTokensLen = rTokens === null || rTokens === void 0 ? void 0 : rTokens.length;
            const effectStream = this.eft.newStream(effectExpr);
            if (policyLen && policyLen !== 0) {
                for (let i = 0; i < policyLen; i++) {
                    const parameters = {};
                    if ((rTokens === null || rTokens === void 0 ? void 0 : rTokens.length) !== rvals.length) {
                        throw new Error(`invalid request size: expected ${rTokensLen}, got ${rvals.length}, rvals: ${rvals}"`);
                    }
                    rTokens.forEach((token, j) => {
                        parameters[token] = rvals[j];
                    });
                    p === null || p === void 0 ? void 0 : p.tokens.forEach((token, j) => {
                        parameters[token] = p === null || p === void 0 ? void 0 : p.policy[i][j];
                    });
                    if (HasEval) {
                        const ruleNames = util_1.getEvalValue(expString);
                        let expWithRule = expString;
                        for (const ruleName of ruleNames) {
                            if (ruleName in parameters) {
                                const rule = util_1.escapeAssertion(parameters[ruleName]);
                                expWithRule = util_1.replaceEval(expWithRule, rule);
                            }
                            else {
                                return false;
                            }
                            expression = this.getExpression(asyncCompile, expWithRule);
                        }
                    }
                    let result;
                    if (expression != undefined) {
                        const context = Object.assign(Object.assign({}, parameters), functions);
                        result = asyncCompile ? yield expression(context) : expression(context);
                    }
                    let eftRes;
                    switch (typeof result) {
                        case 'boolean':
                            eftRes = result ? effect_1.Effect.Allow : effect_1.Effect.Indeterminate;
                            break;
                        case 'number':
                            if (result === 0) {
                                eftRes = effect_1.Effect.Indeterminate;
                            }
                            else {
                                eftRes = result;
                            }
                            break;
                        default:
                            throw new Error('matcher result should be boolean or number');
                    }
                    const eft = parameters['p_eft'];
                    if (eft && eftRes === effect_1.Effect.Allow) {
                        if (eft === 'allow') {
                            eftRes = effect_1.Effect.Allow;
                        }
                        else if (eft === 'deny') {
                            eftRes = effect_1.Effect.Deny;
                        }
                        else {
                            eftRes = effect_1.Effect.Indeterminate;
                        }
                    }
                    const [res, done] = effectStream.pushEffect(eftRes);
                    if (done) {
                        break;
                    }
                }
            }
            else {
                const parameters = {};
                rTokens === null || rTokens === void 0 ? void 0 : rTokens.forEach((token, j) => {
                    parameters[token] = rvals[j];
                });
                (_j = p === null || p === void 0 ? void 0 : p.tokens) === null || _j === void 0 ? void 0 : _j.forEach(token => {
                    parameters[token] = '';
                });
                let result = false;
                if (expression != undefined) {
                    const context = Object.assign(Object.assign({}, parameters), functions);
                    result = asyncCompile ? yield expression(context) : expression(context);
                }
                if (result) {
                    effectStream.pushEffect(effect_1.Effect.Allow);
                }
                else {
                    effectStream.pushEffect(effect_1.Effect.Indeterminate);
                }
            }
            const res = effectStream.current();
            // only generate the request --> result string if the message
            // is going to be logged.
            if (log_1.getLogger().isEnable()) {
                let reqStr = 'Request: ';
                for (let i = 0; i < rvals.length; i++) {
                    if (i !== rvals.length - 1) {
                        reqStr += `${rvals[i]}, `;
                    }
                    else {
                        reqStr += rvals[i];
                    }
                }
                reqStr += ` ---> ${res}`;
                log_1.logPrint(reqStr);
            }
            return res;
        });
    }
    /**
     * If the matchers does not contain an asynchronous method, call it faster.
     *
     * enforceWithSyncCompile decides whether a "subject" can access a "object" with
     * the operation "action", input parameters are usually: (sub, obj, act).
     *
     * @param rvals the request needs to be mediated, usually an array
     *              of strings, can be class instances if ABAC is used.
     * @return whether to allow the request.
     */
    enforceWithSyncCompile(...rvals) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.privateEnforce(false, ...rvals);
        });
    }
    /**
     * enforce decides whether a "subject" can access a "object" with
     * the operation "action", input parameters are usually: (sub, obj, act).
     *
     * @param rvals the request needs to be mediated, usually an array
     *              of strings, can be class instances if ABAC is used.
     * @return whether to allow the request.
     */
    enforce(...rvals) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.privateEnforce(true, ...rvals);
        });
    }
}
exports.CoreEnforcer = CoreEnforcer;
