// Copyright 2018 The Casbin Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { compile, compileAsync } from 'expression-eval';
import { DefaultEffector, Effect } from './effect';
import { FunctionMap, newModel } from './model';
import { DefaultRoleManager } from './rbac';
import { escapeAssertion, generateGFunction, getEvalValue, hasEval, replaceEval } from './util';
import { getLogger, logPrint } from './log';
/**
 * CoreEnforcer defines the core functionality of an enforcer.
 */
export class CoreEnforcer {
    constructor() {
        this.fm = FunctionMap.loadFunctionMap();
        this.eft = new DefaultEffector();
        this.matcherMap = new Map();
        this.watcher = null;
        this.rm = new DefaultRoleManager(10);
        this.enabled = true;
        this.autoSave = true;
        this.autoBuildRoleLinks = true;
        this.autoNotifyWatcher = true;
    }
    getExpression(asyncCompile, exp) {
        const matcherKey = `${asyncCompile ? 'ASYNC[' : 'SYNC['}${exp}]`;
        let expression = this.matcherMap.get(matcherKey);
        if (!expression) {
            expression = asyncCompile ? compileAsync(exp) : compile(exp);
            this.matcherMap.set(matcherKey, expression);
        }
        return expression;
    }
    /**
     * loadModel reloads the model from the model CONF file.
     * Because the policy is attached to a model,
     * so the policy is invalidated and needs to be reloaded by calling LoadPolicy().
     */
    loadModel() {
        this.model = newModel();
        this.model.loadModel(this.modelPath);
        this.model.printModel();
    }
    /**
     * getModel gets the current model.
     *
     * @return the model of the enforcer.
     */
    getModel() {
        return this.model;
    }
    /**
     * setModel sets the current model.
     *
     * @param m the model.
     */
    setModel(m) {
        this.model = m;
    }
    /**
     * getAdapter gets the current adapter.
     *
     * @return the adapter of the enforcer.
     */
    getAdapter() {
        return this.adapter;
    }
    /**
     * setAdapter sets the current adapter.
     *
     * @param adapter the adapter.
     */
    setAdapter(adapter) {
        this.adapter = adapter;
    }
    /**
     * setWatcher sets the current watcher.
     *
     * @param watcher the watcher.
     */
    setWatcher(watcher) {
        this.watcher = watcher;
        watcher.setUpdateCallback(async () => await this.loadPolicy());
    }
    /**
     * setRoleManager sets the current role manager.
     *
     * @param rm the role manager.
     */
    setRoleManager(rm) {
        this.rm = rm;
    }
    /**
     * getRoleManager gets the current role manager.
     */
    getRoleManager() {
        return this.rm;
    }
    /**
     * setEffector sets the current effector.
     *
     * @param eft the effector.
     */
    setEffector(eft) {
        this.eft = eft;
    }
    /**
     * clearPolicy clears all policy.
     */
    clearPolicy() {
        this.model.clearPolicy();
    }
    /**
     * loadPolicy reloads the policy from file/database.
     */
    async loadPolicy() {
        this.model.clearPolicy();
        await this.adapter.loadPolicy(this.model);
        this.model.printPolicy();
        if (this.autoBuildRoleLinks) {
            await this.buildRoleLinksInternal();
        }
    }
    /**
     * loadFilteredPolicy reloads a filtered policy from file/database.
     *
     * @param filter the filter used to specify which type of policy should be loaded.
     */
    async loadFilteredPolicy(filter) {
        this.model.clearPolicy();
        if ('isFiltered' in this.adapter) {
            await this.adapter.loadFilteredPolicy(this.model, filter);
        }
        else {
            throw new Error('filtered policies are not supported by this adapter');
        }
        this.model.printPolicy();
        if (this.autoBuildRoleLinks) {
            await this.buildRoleLinksInternal();
        }
        return true;
    }
    /**
     * isFiltered returns true if the loaded policy has been filtered.
     *
     * @return if the loaded policy has been filtered.
     */
    isFiltered() {
        if ('isFiltered' in this.adapter) {
            return this.adapter.isFiltered();
        }
        return false;
    }
    /**
     * savePolicy saves the current policy (usually after changed with
     * Casbin API) back to file/database.
     */
    async savePolicy() {
        if (this.isFiltered()) {
            throw new Error('Cannot save a filtered policy');
        }
        const flag = await this.adapter.savePolicy(this.model);
        if (!flag) {
            return false;
        }
        if (this.watcher) {
            return await this.watcher.update();
        }
        return true;
    }
    /**
     * enableEnforce changes the enforcing state of Casbin, when Casbin is
     * disabled, all access will be allowed by the enforce() function.
     *
     * @param enable whether to enable the enforcer.
     */
    enableEnforce(enable) {
        this.enabled = enable;
    }
    /**
     * enableLog changes whether to print Casbin log to the standard output.
     *
     * @param enable whether to enable Casbin's log.
     */
    enableLog(enable) {
        getLogger().enableLog(enable);
    }
    /**
     * enableAutoSave controls whether to save a policy rule automatically to
     * the adapter when it is added or removed.
     *
     * @param autoSave whether to enable the AutoSave feature.
     */
    enableAutoSave(autoSave) {
        this.autoSave = autoSave;
    }
    /**
     * enableAutoNotifyWatcher controls whether to save a policy rule automatically notify the Watcher when it is added or removed.
     * @param enable whether to enable the AutoNotifyWatcher feature.
     */
    enableAutoNotifyWatcher(enable) {
        this.autoNotifyWatcher = enable;
    }
    /**
     * enableAutoBuildRoleLinks controls whether to save a policy rule
     * automatically to the adapter when it is added or removed.
     *
     * @param autoBuildRoleLinks whether to automatically build the role links.
     */
    enableAutoBuildRoleLinks(autoBuildRoleLinks) {
        this.autoBuildRoleLinks = autoBuildRoleLinks;
    }
    /**
     * buildRoleLinks manually rebuild the role inheritance relations.
     */
    async buildRoleLinks() {
        return this.buildRoleLinksInternal();
    }
    /**
     * buildIncrementalRoleLinks provides incremental build the role inheritance relations.
     * @param op policy operation
     * @param ptype g
     * @param rules policies
     */
    async buildIncrementalRoleLinks(op, ptype, rules) {
        await this.model.buildIncrementalRoleLinks(this.rm, op, 'g', ptype, rules);
    }
    async buildRoleLinksInternal() {
        await this.rm.clear();
        await this.model.buildRoleLinks(this.rm);
    }
    async privateEnforce(asyncCompile = true, ...rvals) {
        if (!this.enabled) {
            return true;
        }
        const functions = {};
        this.fm.getFunctions().forEach((value, key) => {
            functions[key] = value;
        });
        const astMap = this.model.model.get('g');
        astMap?.forEach((value, key) => {
            const rm = value.rm;
            functions[key] = generateGFunction(rm);
        });
        const expString = this.model.model.get('m')?.get('m')?.value;
        if (!expString) {
            throw new Error('Unable to find matchers in model');
        }
        const effectExpr = this.model.model.get('e')?.get('e')?.value;
        if (!effectExpr) {
            throw new Error('Unable to find policy_effect in model');
        }
        const HasEval = hasEval(expString);
        let expression;
        if (!HasEval) {
            expression = this.getExpression(asyncCompile, expString);
        }
        const p = this.model.model.get('p')?.get('p');
        const policyLen = p?.policy?.length;
        const rTokens = this.model.model.get('r')?.get('r')?.tokens;
        const rTokensLen = rTokens?.length;
        const effectStream = this.eft.newStream(effectExpr);
        if (policyLen && policyLen !== 0) {
            for (let i = 0; i < policyLen; i++) {
                const parameters = {};
                if (rTokens?.length !== rvals.length) {
                    throw new Error(`invalid request size: expected ${rTokensLen}, got ${rvals.length}, rvals: ${rvals}"`);
                }
                rTokens.forEach((token, j) => {
                    parameters[token] = rvals[j];
                });
                p?.tokens.forEach((token, j) => {
                    parameters[token] = p?.policy[i][j];
                });
                if (HasEval) {
                    const ruleNames = getEvalValue(expString);
                    let expWithRule = expString;
                    for (const ruleName of ruleNames) {
                        if (ruleName in parameters) {
                            const rule = escapeAssertion(parameters[ruleName]);
                            expWithRule = replaceEval(expWithRule, rule);
                        }
                        else {
                            return false;
                        }
                        expression = this.getExpression(asyncCompile, expWithRule);
                    }
                }
                let result;
                if (expression != undefined) {
                    const context = { ...parameters, ...functions };
                    result = asyncCompile ? await expression(context) : expression(context);
                }
                let eftRes;
                switch (typeof result) {
                    case 'boolean':
                        eftRes = result ? Effect.Allow : Effect.Indeterminate;
                        break;
                    case 'number':
                        if (result === 0) {
                            eftRes = Effect.Indeterminate;
                        }
                        else {
                            eftRes = result;
                        }
                        break;
                    default:
                        throw new Error('matcher result should be boolean or number');
                }
                const eft = parameters['p_eft'];
                if (eft && eftRes === Effect.Allow) {
                    if (eft === 'allow') {
                        eftRes = Effect.Allow;
                    }
                    else if (eft === 'deny') {
                        eftRes = Effect.Deny;
                    }
                    else {
                        eftRes = Effect.Indeterminate;
                    }
                }
                const [res, done] = effectStream.pushEffect(eftRes);
                if (done) {
                    break;
                }
            }
        }
        else {
            const parameters = {};
            rTokens?.forEach((token, j) => {
                parameters[token] = rvals[j];
            });
            p?.tokens?.forEach(token => {
                parameters[token] = '';
            });
            let result = false;
            if (expression != undefined) {
                const context = { ...parameters, ...functions };
                result = asyncCompile ? await expression(context) : expression(context);
            }
            if (result) {
                effectStream.pushEffect(Effect.Allow);
            }
            else {
                effectStream.pushEffect(Effect.Indeterminate);
            }
        }
        const res = effectStream.current();
        // only generate the request --> result string if the message
        // is going to be logged.
        if (getLogger().isEnable()) {
            let reqStr = 'Request: ';
            for (let i = 0; i < rvals.length; i++) {
                if (i !== rvals.length - 1) {
                    reqStr += `${rvals[i]}, `;
                }
                else {
                    reqStr += rvals[i];
                }
            }
            reqStr += ` ---> ${res}`;
            logPrint(reqStr);
        }
        return res;
    }
    /**
     * If the matchers does not contain an asynchronous method, call it faster.
     *
     * enforceWithSyncCompile decides whether a "subject" can access a "object" with
     * the operation "action", input parameters are usually: (sub, obj, act).
     *
     * @param rvals the request needs to be mediated, usually an array
     *              of strings, can be class instances if ABAC is used.
     * @return whether to allow the request.
     */
    async enforceWithSyncCompile(...rvals) {
        return this.privateEnforce(false, ...rvals);
    }
    /**
     * enforce decides whether a "subject" can access a "object" with
     * the operation "action", input parameters are usually: (sub, obj, act).
     *
     * @param rvals the request needs to be mediated, usually an array
     *              of strings, can be class instances if ABAC is used.
     * @return whether to allow the request.
     */
    async enforce(...rvals) {
        return this.privateEnforce(true, ...rvals);
    }
}
